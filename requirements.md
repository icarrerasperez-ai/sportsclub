# Version pinning and security checks of dependencies

#### Objetivos
- [x] *requirements.txt* mejorado
- [x] *requirements.md* con las peguntas respondidas
- [ ] *dependencias.md* con las preguntas respondidas sobre las vulnerabilidades del proyecto
- [ ] *Links* a los ficheros en nuestro fork.

---

## 1. Que problemas encuentras en terminos de seguridad y como los resolverias? (Version pinning VS hashing)
#### Detección del problema
El principal problema de tener el versionado tal cual muestra el documento es que este solo depende de *Versiones por Pinning*, es decir que utiliza dos iguales para especificar la version. 
![[Pasted image 20260202175019.png]]
Esto esta bien hasta cierto punto pues si que es verdad que por lo menos si que estas cogiendo una version concreta, lo cual en caso de actualizacion o de nuevo deploy no se rompera. Pero este metodo no nos garantiza que el contenido dentro de la dependencia que estamos descargando sea el original, por lo que estamos en peligro nuevamente.
#### Solución
Para solucionar el problema anterior del *Version Pinning* utilizaremos *hashes criptograficos*. Esto quiere decir que a cada modulo le calculamos su respectivo hash de contenido. 
**Que ganamos con esto?**
Con esto conseguimos asegurarnos de que el contenido que se instala en los equipos es exactamente el mismo que se a instalado en el nuestro pues si el hash no coincide no se esta haciendo bien. 
### Opcional: Busca Lock files vs Input Files

---

## 2. Modifica el fichero y crea uno nuevo, mejora las versiones mediante tu fork de Git. Como llegas a ese resultado? Entrega los dos ficheros
Para implementar los hashes criptograficos en el fichero requirements.txt, lo primero que haremos es hacer una "copia" de este a modo de copia de seguridad a la cual llamaremos `requirements_old.txt` y crearemos un nuevo fichero con el mismo contenido y con el mismo nombre requirements.txt. La herramienta que utilizaremos sera: *pip-compose*
### Instalacion
Para instalar esta herramienta es tan sencillo como lanzar desde la terminal el siguiente comando.
```sh
pip install pip-tools
```
![[Pasted image 20260203154040.png]]

Una vez con las *pip-tools* instaladas procedemos a hashear las dependencias.
```python
python -m piptools compile --generate-hashes requirements.in

# Tambien he intentado lanzar la instruccion tal cual pero no me dejaba el sistema
pip-compile --generate-hashes requirements.in
```
![[Pasted image 20260203154326.png]]
![[Pasted image 20260203154426.png]]

El resultado de lanzar este comando es un fichero requirements.txt con el contenido siguiente:
```txt
#
# This file is autogenerated by pip-compile with Python 3.12
# by the following command:
#
# pip-compile --generate-hashes requirements.in
#
annotated-types==0.7.0 \
--hash=sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53 \
--hash=sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89
# via
# -r requirements.in
# pydantic
asgiref==3.11.0 \
--hash=sha256:13acff32519542a1736223fb79a715acdebe24286d98e8b164a73085f40da2c4 \
--hash=sha256:1db9021efadb0d9512ce8ffaf72fcef601c7b73a8807a1bb2ef143dc6b14846d
# via
# -r requirements.in
# django
# django-cors-headers
django==6.0 \
--hash=sha256:1cc2c7344303bbfb7ba5070487c17f7fc0b7174bbb0a38cebf03c675f5f19b6d \
--hash=sha256:7b0c1f50c0759bbe6331c6a39c89ae022a84672674aeda908784617ef47d8e26
# via
# -r requirements.in
# django-cors-headers
# django-nanoid-field
# django-ninja
django-cors-headers==4.9.0 \
--hash=sha256:15c7f20727f90044dcee2216a9fd7303741a864865f0c3657e28b7056f61b449 \
--hash=sha256:fe5d7cb59fdc2c8c646ce84b727ac2bca8912a247e6e68e1fb507372178e59e8
# via -r requirements.in
...
```
![[Pasted image 20260203154638.png]]

Con el fichero ya hasheado separamos las dependencias de *Produccion* y las dependecias de *desarrollo* con un comentario
**Produccion**:
![[Pasted image 20260203160525.png]]

**Desarrollo**
![[Pasted image 20260203160624.png]]

---
## 3. Describe el procedimiento que recomendarias en un escenario de produccion para hacer mas modificaciones

### Filosofia Unica fuente de verdad (SSoT)
Este metodo consiste en que cada pieza de informacion debe tener un lugar unico como fuente oficial de origen.

**¿Que ganamos?**
Si utilizamos el fichero `.txt` corremos el reisgo de que este si una de las dependencias es modificada pero no su hash entonces la instalacion falla.
Por lo que cada vez que hacemos una modificacion el trabajo de divide en 2 partes 
1. Archivo `.in`: Es un archivo donde se escribe solo lo realmente necesario
2. Archivo `.txt`: Este es el archivo generado por la maquina con las versiones y hashes respectivos.
### Actualizaciones controladas
Para un mayor control sobre las versiones lo que haremos es realizar actualizaciones controladas tanto de todas las dependencias como solo de una concreta. Para esto podemos utilizar `--upgrade-package` si queremos actualizar una unica dependencia, mientras que si queremos actualizarlas todas podemos utilizar `--upgrade`.
```sh
# Solo para actualizar django
pip-compile --upgrade-package django --generate-hashes requirements.txt.orig

# Actualizar todas las dependencias
pip-compile --upgrade --generate-hashes requirements.in
```
Actualizacion exclusiva de *django*.
![[Pasted image 20260203163019.png]]

Actualizacion de todas las dependencias.
![[Pasted image 20260203163157.png]]

### Escaneo de Vulnerabilidades
Para el escaneo de vulnerabilidades del requirements.txt utilizaremos la herramienta pip-audit que comprueba los hashes y se asegura de que no tenga CVE conocidas / asociadas a ese hash.
```sh
pip-audit -r requirements.txt
```
![[Pasted image 20260203163804.png]]

---
## 4. Que escenario estas intentando evitar con estas versiones nuevas?
El escenario o escenarios que estamos evitando con este nuevo control de versiones son:
- *Inconsistencia de versiones* lo cual puede acarrear que en diferentes equipos no funcione por lo que asegurandonos de que son las mismas versiones y con el mismo contenido estamos consiguiendo evitar el famoso "En mi equipo funciona".
- *Supply Chain Atacks*: Al tener el codigo hasheado el equipo se descargara exactamente lo mismo que tenemos nosotros por lo que evitaremos cualquier incidente.
- Al estar en monitoreo constante prevenimos dejar *dependencias sin uso* en el fichero requirements.txt por lo que evitamos tener *codigo muerto*.
